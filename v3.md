

## catalog_manager

里面记录了表的属性，格式为：{table_name:table}

| 表的属性    | 含义                                                     |
| ----------- | -------------------------------------------------------- |
| column_list | 列的名称字典，格式为：{cloumn_name:column_no, is_unique} |
| fmt_list    | 格式的列表，格式为：fmt                                  |
| index_list  | 索引的字典，格式为：index:root                           |
| page_header | 第一个数据页的位置                                       |
| primary_key | 主键名称                                                 |

## thread_manager（暂时不需要管）

thread_manager提供一个锁，使用with request(table_name, priority)

当执行with中的内容时，不允许别的线程访问同一个table的buffer和catalog（不同的table是可以的）

## buffer_manager

| 属性        | 说明                                            |
| ----------- | ----------------------------------------------- |
| buffer_pool | 字典，{page_no:page，acquire_times}             |
| pool_size   | 缓冲池最大的页数                                |
| del_header  | 删除链表的头节点，是page_no。如果不存在，则是-1 |
| heap_top    | 指向当前页数最大的一页                          |

page的内容：

| 键           | 含义                                           | 类型   |
| ------------ | ---------------------------------------------- | ------ |
| next_page    | 下一个页号，页号在读写的时候会计算为字符串地址 | int    |
| current_page | 当前页号                                       | int    |
| parent       | 如果是非树节点，则为-1，否则为父节点偏移量     | int    |
| fmt_size     | fmt长度                                        | int    |
| index_no     | 索引在record中的位置                           | int    |
| is_leaf      | True表示是叶子节点                             | bool   |
| fmt          | 页解码模式                                     | string |
| user_record  | 存储的数据                                     | 列表   |



| 方法          | 含义                                                         | 是否加锁 |
| ------------- | ------------------------------------------------------------ | -------- |
| \_\_init\_\_  | 如果buffer_manager不存在，则从文件中读取属性，否则不做，可以看出类的构造函数 | 否       |
| \_\_del\_\_   | 将buffer_pool写入文件，看出类的析构函数                      | 否       |
| load_buffer   | 将文件加入buffer_pool。在未命中时使用                        | 否       |
| unload_buffer | 将buffer写入文件，并在buffer_pool中删除，buffer_pool满时使用 | 否       |
| pre_read      | 不加锁读取，用来修改buffer，必须在外面使用write权限          | 否       |
| read_buffer   | 读取buffer_pool中的buffer                                    | 否       |
| new_buffer    | 新建一个文件，加入buffer_pool，并返回page_no                 | 否       |
| delete_buffer | 删除page_no对应的文件（不是物理删除）                        | 否       |
| read_json     | 读取物理文件                                                 | 否       |
| write_json    | 修改物理文件                                                 | 否       |



## record_manager：

根据索引找到位置插入。

在缓存中，record是一个list，插入时需要按照索引值插入，修改方式是修改page在的user_record

在文件中，record按照顺序写入文件。

## index_manager:

如果超出，则调用index_manager进行维护，新的节点被分配新的页数，并修改

一条非叶节点的属性：[key,page_no]，page_no是int，就是页号

## request

实例化一个对象，传递给wait_list，然后在wait中修改，然后退出

